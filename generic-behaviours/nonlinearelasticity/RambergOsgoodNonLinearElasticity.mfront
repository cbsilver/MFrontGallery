@DSL Default;
@Behaviour RambergOsgoodNonLinearElasticity;
@Author L. Gelebart/V. Duc Nguyen;
@Description {
  "Ramberg-Osgood model (non-(linear elastic formulation)"
  "Eps = S:Sig +β.σ_eq^n. N"
  "with:"
  " - N = (3/2) Sig_dev / σ_eq"
  " - σ_eq = rac((3/2)σ_dev:σ_dev))"
  " - β = α⋅σ₀/E"
}

@MaterialProperty stress E;
E.setGlossaryName("YoungModulus");

@MaterialProperty real ν;
ν.setGlossaryName("PoissonRatio");

@MaterialProperty real n;
@MaterialProperty real α;
α.setEntryName("alpha");
@MaterialProperty stress σ₀;
σ₀.setGlossaryName("YieldStrength");

//! the shear modulus
@LocalVariable stress μ;
//! the bulk modulus
@LocalVariable stress K;
//! an helper variable
@LocalVariable real β;
//! von Mises equivalent stress
@LocalVariable stress σₑ;
/*!
 * derivative of the von Mises equivalent stress
 * with respect to the equivalent strain
 */
@LocalVariable stress ∂σₑ∕∂εₑ;

@Parameter real e_ε = 1e-12;

@InitLocalVariables {
  μ = computeMu(E, ν);
  K = E / (3 ⋅ (1 - 2 ⋅ ν));
  β = α ⋅ σ₀ / E;
  σₑ = stress{};
  ∂σₑ∕∂εₑ = stress{};
}

@PredictionOperator{
  const auto P = I₄ - (I₂ ⊗ I₂) / 3;
  Dt = K ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ P;
}

@Integrator{
  auto computeEquivalentStressAndDerivative = [this](const strain εₑ)
      ->std::tuple<stress, stress> {
    const auto e_σ = E ⋅ e_ε;
    const auto i3μ = 1 / (3 ⋅ μ);
    auto fdf = [&](const stress σₑ) -> tuple<real, stress> {
      const auto rσₑⁿ = pow(σₑ / σ₀, n);
      const auto iσₑ = 1 / max(e_σ, σₑ);
      return {σₑ ⋅ i3μ + β ⋅ rσₑⁿ - εₑ, //
              1 / max(i3μ + n ⋅ β ⋅ rσₑⁿ ⋅ iσₑ, i3μ ⋅ e_ε)};
    };
    if (εₑ < e_ε) {
      return {3 ⋅ μ ⋅ εₑ, 3 ⋅ μ};
    }
    σₑ = σ₀ ⋅ pow(εₑ / β, 1 / n);
    auto r = real{};
    tie(r, ∂σₑ∕∂εₑ) = fdf(σₑ);
    auto iter = int{};
    while (abs(r) > e_ε) {
      tie(r, ∂σₑ∕∂εₑ) = fdf(σₑ);
      σₑ -= r ⋅ ∂σₑ∕∂εₑ;
      if (++iter > 20) {
        throw(DivergenceException());
      }
    }
    return {σₑ, ∂σₑ∕∂εₑ};
  }; // end of computeEquivalentStressAndDerivative
  const auto ε = εᵗᵒ + Δεᵗᵒ;
  σ = K ⋅ trace(ε) ⋅ I₂;
  // Deviatoric part
  const auto se = deviator(ε);
  const auto εₑ = sqrt(2 ⋅ (se | se) / 3);
  const auto iεₑ = 1 / max(εₑ, e_ε);
  const auto ne = 2 ⋅ se ⋅ (iεₑ / 3);
  auto σₑ = stress{};
  auto ∂σₑ∕∂εₑ = stress{};
  tie(σₑ,∂σₑ∕∂εₑ) = computeEquivalentStressAndDerivative(εₑ);
  σ += σₑ ⋅ ne;
}

@TangentOperator{
  const auto P = I₄ - (I₂ ⊗ I₂) / 3;
  if (εₑ < e_ε) {
    Dt = K ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ P;
  } else {
    Dt = K ⋅ (I₂ ⊗ I₂) + ∂σₑ∕∂εₑ ⋅ (ne ⊗ ne) +
         σₑ ⋅ iεₑ ⋅ (2 ⋅ P / 3 - (ne ⊗ ne));
  }
}
